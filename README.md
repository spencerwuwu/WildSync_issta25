# Artifact Evalution for WildSync

This artifact evaluation is for the paper 
"WildSync: Automated Fuzzing Harness Synthesis\\ via Wild API Usage Recovery".

The artifact is divided into two parts:
1. Demo for the synthesis of fuzzing harnness (`WildSync_Demo/`)
2. Reproduction of the evaluation results (`Evaluation/`)


## System requirements
The artifact has been tested on Linux machines with the following requirements:
- Python 3.6 or later and pip
- Docker
- sudo access for changing the permission of the files OSS-Fuzz generates


## Installing Dependencies
Run `./tools/install_deps.sh`, this will:
1. Install required python dependencies
2. Install WildSync, which is wrapped as a python packages as well
3. Build base Docker images for evaluation reproduce


--------------------------------------------
## Demo for the synthesis of fuzzing harnness

First, we provide a demo for the synthesis of fuzzing harnness.
All contents are in the `WildSync_Demo/` directory.

### Run the demo
```bash
cd WildSync_Demo/auto_extract
./ARTIFACT_synthesize.sh captainrc
```
The script will synthesize the fuzzing harness for `ov_time_seek`
from `vorbis` library based on the provided example files:
- `external.cpp`: the example external useage
- `vorbis_fuzzer.cc`: the existing fuzzer for `vorbis`
- `vorbis_symbols.txt`: contains the symbols from `vorbis` library
- `pair.json`: the pair of the example external useage and the existing fuzzer
- `generated.cc`: the synthesized fuzzing harness


--------------------------------------------
## Reproduction of the evaluation results

In this part, we provide the steps to reproduce the evaluation results.
All contents are in the `Evaluation/` directory.

Contents:
- `Sec_5-5_Effectiveness_Table2/`
   - This directory contains the scripts to run OSS-Fuzz's original
     and WildSync's added harnesses to compare their coverage.
     We use a script to parse logs generated by libFuzzer to collect harnesses that crash
     and separate the timeout/oom ones.
- `Sec_5-6_Comparison_Table4/`
   - This directory contains the scripts to reproduce the results of Hopper in our benchmark.
     The build scripts for libraries that Hopper failed are provided too.
- `Sec_5-6_Comparison_Table5/`
   - This directory contains the scripts to run WildSync on the versions of library presented
     in Hopper's infrastructure. 
     The structure is similar to the directory for Table 2, just with different set of 
     library and corresponding library versions.

**NOTE**: please use `file` as entry for `libmagic` in Table 5.

**NOTE**: When running the scripts for Table 2 and 5, you may encounter warning such as:
```
There are mis-archived folders. Please check.
<path>/Sec_5-6_Comparison_Table5/workdir/ar/libfuzzer/libpcap/fuzz_both/5
```
This is a hard synchronizing issue for our scripts. In this case, please:
1. Check which of the numbered directories are empty, replace with the ones number larger than 4
   (e.g. In the above scenario, you may find directory 0-5 in `.../fuzz_both/`.
   Say 3 is empty, remove 3 and move 5 as 3.)

2. Resume with `./do_coverage.sh captainrc` to proceed with coverage collection


### Reproducing Section 5.5 Table 2
Steps:
1. First, set up the experiment configuration `captainrc`.
   Please refer to the `captainrc` file for the configuration details.
   Note that each fuzzing instance will takes up one CPU entirely until finish.
   For example, if you set to run `fribidi` with 1hr. `fribidi` contains
   4 fuzzing harnesses. Each fuzzing target is set to run 5 rounds directly.
   The total resource required will be 4*5=20 CPUs, each running for 1 hr.

   Minimum fuzzing time of 300 seconds is recommended for libFuzzer
   to be fully set up inside a Docker container.

2. Start the experiment by running 
   ```bash
   ./ARTIFACT_do_fuzz.sh captainrc
   ```
   The sudo command is required to change the permission of the files OSS-Fuzz generates
   to calculate coverage after fuzzing the libraries.
   If you accidentally missed the sudo password input, you can run the following commands
   to resume the coverage collection process:
   ```bash
   sudo chmod -R 777 {workdir_you_set}
   ./do_coverage.sh captainrc
   ```

3. After finishing Step2, uncomment the libraries being fuzzed in `inforc` "targets" list.
   Then, execute the following command to obtain the line and function coverage stats:
  ```bash
  ./ARTIFACT_post_fuzz.sh captainrc
  ```
  This should display the similar coverage report presented in our paper.
  Note that the crash numbers showing here may not indicate actual crashes, but just a quick parsing results of libFuzzer's log. 
  For example, the warning messages emit by `libgd` make it impossible to collect a clean fuzzing log. Manual effort is necessary for the actual crash numbers.


### Reproducing Section 5.6 Table 4

Do note that as Hopper generates humongous amount of harnesses, it may take up to extra 24 hours to 
"translate" Hopper's results to C file, so that they can be compiled again to calculate coverage.

Steps:
1. Edit `captainrc` to set the targets to test for

2. Run `ARTIFACT_do_fuzz.sh captainrc`, this will

3. After finishing Step2, uncomment the libraries being fuzzed in `inforc` "targets" list.
   Then, execute the following command to obtain the line and function coverage stats:
  ```bash
  ./ARTIFACT_post_fuzz.sh captainrc
  ```

### Reproducing Section 5.6 Table 5
Same procedure for Table 2
1. Edit `captainrc`, run `ARTIFACT_do_fuzz.sh captainrc`

2. Run `ARTIFACT_post_fuzz.sh captainrc`

3. Run `parse_libfuzzer_logs.py` to see crashes encountered
